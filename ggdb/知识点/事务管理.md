## 事务的隔离级别
### 事务有哪些特性？
这里事务是基于MySQL的，在MySQL中，我们常见的 InnoDB是支持事务的。但不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数的 MySQL 的引擎都是使用 InnoDB；事务必须遵守一下4个特征

- **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束再中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；
- **一致性（Consistency）**：指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态；
- **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改能力，隔离性可以防止多个事务并发执行时由于交叉执行导致数据的不一致，因为多个事务同时使用相同数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的；
- **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

InnoDB是通过以下几种方式保持事务的

- 原子性是通过 redo log（重做日志）来保证的；
- 一致性是通过 undo log（回滚日志）来保证的；
- 隔离性是通过 MVCC（并发版本控制）来保证的；
- 持久性是通过 原子性 + 一致性 + 隔离性 来保证的；
### 并发事务会引起哪些问题？
MySQL服务器端是允许多个客户端连接的，所以会存在同时处理多个事务的问题，那么在同时处理多个事务的时候，就有可能出现**脏读（dirty read），不可重复读（non-repeatable read）、幻读（phantom read）**的问题。
#### 脏读
如果一个**事务**读取到另一个**没有提交的事务的数据**，就意味着发生了脏读的现象
假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。
![](https://cdn.nlark.com/yuque/0/2024/png/22796888/1712888108087-2161f354-0a86-4a9c-9157-6d029df975ec.png#averageHue=%23f9f6f1&clientId=u934178b2-8c7e-4&from=paste&id=u106841ad&originHeight=420&originWidth=1080&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u75cb65fc-e507-4394-83f9-f093fba25b2&title=)
因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，**如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。**
#### 不可重复读
**在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。**
假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，**在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。**
![](https://cdn.nlark.com/yuque/0/2024/png/22796888/1712888207729-a33d5799-81a1-463a-9005-0e4fb417f6f1.png#averageHue=%23f9f7f0&clientId=u934178b2-8c7e-4&from=paste&id=ub99d2a11&originHeight=486&originWidth=1080&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u7ae6a393-de57-4a29-b2f3-f6780d5f97e&title=)
#### 幻读
**在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。**
假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。
![](https://cdn.nlark.com/yuque/0/2024/png/22796888/1712888238388-d9900b36-289b-4cdb-a97e-137800f3bcfc.png#averageHue=%23f8f5ef&clientId=u934178b2-8c7e-4&from=paste&id=u73aa9020&originHeight=312&originWidth=1080&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ueccee5e6-61d7-465a-b6c5-9c50821aa01&title=)
接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。
然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，**发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。**
### 事务的隔离级别
当多个事务并发执行的时候可能会遇到 **[脏读、幻读、不可重复读] **的现象，这些现象会对事务的一致性产生不同程序的影响。

- 脏读：读到其他未提交事务的数据；
- 不可重复读：前后读取的数据不一致；
- 幻读：前后读取的数据数量不一致；

这三个现象严重排序如下：
![](https://cdn.nlark.com/yuque/0/2024/png/22796888/1712888486325-1b39300a-fe50-41c5-b117-29516406da90.png#averageHue=%23f4e8e2&clientId=u934178b2-8c7e-4&from=paste&id=u84bd6b83&originHeight=140&originWidth=677&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=udcca6eb4-1517-4493-bf17-845c53cec4f&title=)
QL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（_read uncommitted_）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（_read committed_）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（_repeatable read_）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（_serializable_ ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

按隔离水平高低排序如下：
![](https://cdn.nlark.com/yuque/0/2024/png/22796888/1712889056259-f797f79a-9881-4e6c-89c6-6d14b1d40844.png#averageHue=%23f5ebe3&clientId=u934178b2-8c7e-4&from=paste&id=uc07bb983&originHeight=144&originWidth=962&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ub7e0de66-162f-4b28-8d3d-1e0a8dcee6e&title=)
针对不同的隔离级别，并发事务时可能发生的现象也会不同。
![](https://cdn.nlark.com/yuque/0/2024/png/22796888/1712889056324-7176a1a8-3c50-4f9f-a4e7-2e37da9e6f70.png#averageHue=%23f7f6e0&clientId=u934178b2-8c7e-4&from=paste&id=u250a3761&originHeight=464&originWidth=1080&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ua2fbd764-c2b7-4126-a22f-07e18780c0e&title=)
也就是说：

- 在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；
- 在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；
- 在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；
- 在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。

所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。

MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。
**MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇**[文章(opens new window)](https://xiaolincoding.com/mysql/transaction/phantom.html)**）**，解决的方案有两种：

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：
![](https://cdn.nlark.com/yuque/0/2024/png/22796888/1712889056191-5e9fac1e-0301-48d2-af14-04b9569c934b.png#averageHue=%23e3ea9d&clientId=u934178b2-8c7e-4&from=paste&id=u21dbfcf3&originHeight=542&originWidth=452&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u31a90ef5-e686-479b-8581-3c18a79d726&title=)
在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：

- 在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；
- 在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；
- 在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；
- 在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。

这四种隔离级别具体是如何实现的呢？

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。
> 转载：[https://www.xiaolincoding.com/mysql/transaction/mvcc.html](https://www.xiaolincoding.com/mysql/transaction/mvcc.html)

